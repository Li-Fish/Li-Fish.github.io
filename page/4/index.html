<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Fish&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Fish&#39;s Blog">
<meta property="og:url" content="https://li-fish.github.io/page/4/index.html">
<meta property="og:site_name" content="Fish&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fish&#39;s Blog">
  
    <link rel="alternate" href="/atom.xml" title="Fish&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fish&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://li-fish.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-K-D树小结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/cjsli5r3600fn3oc20jjrg4yn/" class="article-date">
  <time datetime="2017-11-20T11:05:08.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/数据结构/">数据结构</a>►<a class="article-category-link" href="/categories/ACM/数据结构/K-D树/">K-D树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/cjsli5r3600fn3oc20jjrg4yn/">K-D树小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="资料-amp-感谢"><a href="#资料-amp-感谢" class="headerlink" title="资料&amp;感谢"></a>资料&amp;感谢</h1><p><a href="https://blog.sengxian.com/algorithms/k-dimensional-tree" target="_blank" rel="noopener"><a href="https://blog.sengxian.com/" target="_blank" rel="noopener">Sengxian’s Blog</a></a></p>
<p><a href="https://www.bilibili.com/video/av7039143/?from=search&amp;seid=12824880607180236401" target="_blank" rel="noopener">QSC算法讲堂</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>K-D 树是 K 维树（k-dimensional tree）的缩写，可以用来寻找 K 维空间中距离一个点最近的若干个点，不过在 ACM 中一般用来处理平面的最近点对问题。</p>
<p>K-D 树实质上是一颗二叉树，所以可以做到插入删除点都是 $O(\log n)$，在建树的时候每次按一个维度排序后，取中间点把空间划分为两部分，在这个维度上小于中间点的放到左儿子，大于中间点的放到右儿子。</p>
<p>这里为了简单，首先从一维的 K-D 树入手。</p>
<h2 id="一维的-K-D-树"><a href="#一维的-K-D-树" class="headerlink" title="一维的 K-D 树"></a>一维的 K-D 树</h2><p><img src="http://chuantu.biz/t6/152/1511176656x-1566638157.png" alt="一维 K-D 树"></p>
<p>上图是一颗一维的 K-D，对于一维的情况，所有的点都是数轴上的点，那么这时候<br>K-D 树就是一颗普通的二叉搜索树（Binary Search Tree）。</p>
<h2 id="二维的-K-D-树"><a href="#二维的-K-D-树" class="headerlink" title="二维的 K-D 树"></a>二维的 K-D 树</h2><p><img src="http://chuantu.biz/t6/152/1511176920x-1566638157.png" alt="二维 K-D 树"></p>
<p>这时候就是交替的按 x 维和 y 维排序进行划分的。上面就是对点集 <code>(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)</code>的划分。</p>
<p><img src="http://chuantu.biz/t6/152/1511177069x-1566638157.png" alt=""></p>
<p>上面的划分对应的树型结构就是这样的，对于第一层，左子树的点的 x 坐标都小于根节点，右子树的点的 x 坐标都大于根节点。对于第二层，左子树的点的 y 坐标都小于根节点，右子树的点的 y 坐标都大于根节点，以此类推。</p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>K-D 树的每个节点不仅要保存当前点的坐标信息，还要维护当前子树每个维度上的边界点。</p>
<p>这里 <a href="https://blog.sengxian.com/algorithms/k-dimensional-tree" target="_blank" rel="noopener">Sengxian</a> 巨巨写的非常好，就直接引用了。</p>
<blockquote>
<p>在构造 1 维 BST 树时，一个 1 维数据根据其与树的根结点进行大小比较，来决定是划分到左子树还是右子树。<br>同理，我们也可以按照这样的方式，将一个 $k$ 维数据与 k-d树 的根结点进行比较，只不过不是对 $k$ 维数据进行整体的比较，而是选择某一个维度 $D_i$，然后比较两个数据在该维度 $D_i$ 上的大小关系，即每次选择一个维度 $D_i$ 来对 $k$ 维数据进行划分，相当于用一个垂直于该维度 $D_i$ 的超平面将 $k$ 维数据空间一分为二，平面一边的所有 $k$ 维数据在 $D_i$ 维度上的值小于平面另一边的所有 $k$ 维数据对应维度上的值。<br>也就是说，我们每选择一个维度进行如上的划分，就会将 $k$ 维数据空间划分为两个部分，如果我们继续分别对这两个子 $k$ 维空间进行如上的划分，又会得到新的子空间，对新的子空间又继续划分，重复以上过程直到每个子空间都不能再划分为止。以上就是构造 k-d树 的过程。<br>那么如果是二维特殊情况，就变得非常好理解了，通俗的来说就是通过过已有点的横线，竖线来划分二维平面。<br>上述过程中涉及到两个重要的问题：</p>
<ol>
<li>每次对子空间的划分时，怎样确定在哪个维度上进行划分？</li>
<li>在某个维度上进行划分时，怎样确保在这一维度上的划分得到的两个子集合的数量尽量相等，即左子树和右子树中的结点个数尽量相等？</li>
</ol>
<p>对于第一个问题，有很多种方法可以选择划分维度（axis-aligned splitting planes），所以有很多种创建 k-d树 的方法。 最典型的方法如下：<br>随着树的深度轮流选择维度来划分。例如，在二维空间中根节点以 x 轴划分，其子节点皆以 y 轴划分，其孙节点又以 x 轴划分，其曾孙节点则皆为 y 轴划分，依此类推。<br>另外的划分方法还有最大方差法（max invarince），在这里不做介绍。</p>
<p>而对于第二个问题，也是在 BST 中会遇到的一个问题。在 BST 中，我们是将数据的中位数作为根节点，然后再左右递归下去建树，这样可以得到一棵平衡的二叉搜索树。<br>同样，在 k-d树 中，若在维度 $D_i$ 上进行划分时，根节点就应该选择该维度 $D_i$ 上所有数据的中位数，这样递归子树的大小就基本相同了。</p>
</blockquote>
<h2 id="K-D-树单个节点"><a href="#K-D-树单个节点" class="headerlink" title="K-D 树单个节点"></a>K-D 树单个节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//d 数组储存当前点，minn 和 maxn 表示当前节点维护的矩形的边界</span></span><br><span class="line">    <span class="keyword">int</span> d[DIM], minn[DIM], maxn[DIM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对节点进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">            minn[i] = maxn[i] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过修改全局变量 D，实现按不同维度排序</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    <span class="comment">//将中间数放到 mid 位置，小于中间数的放左边，大于的放右边，不保证左右边有序，类似快排的一部分，复杂度O(N)</span></span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化节点信息</span></span><br><span class="line">    tree[mid].maintain();</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="comment">//维护子树信息</span></span><br><span class="line">    pushUp(mid);</span><br><span class="line">    re</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> k, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前节点为空，就直接将赋值</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">0</span>) &#123;</span><br><span class="line">        o = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则根据 now 维的大小进行二分查找</span></span><br><span class="line">    <span class="keyword">if</span> (tree[k].d[now] &lt; tree[o].d[now]) insert(tree[o].l, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">else</span> insert(tree[o].r, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="comment">//插入节点后更新信息</span></span><br><span class="line">    pushUp(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="最近点"><a href="#最近点" class="headerlink" title="最近点"></a>最近点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当前查找的点距离节点维护的矩阵的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += tree[k].d[i] - tree[o].maxn[i];</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += tree[o].minn[i] - tree[k].d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过当前节点储存的点更新答案</span></span><br><span class="line">    <span class="keyword">int</span> dm = <span class="built_in">abs</span>(tree[o].d[<span class="number">0</span>] - tree[k].d[<span class="number">0</span>]) + <span class="built_in">abs</span>(tree[o].d[<span class="number">1</span>] - tree[k].d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dm &lt; ans) ans = dm;</span><br><span class="line">    <span class="comment">//计算左右子树距离当前点可能的最近的答案</span></span><br><span class="line">    <span class="keyword">int</span> dl = tree[o].l ? partionMin(tree[o].l, k) : INF;</span><br><span class="line">    <span class="keyword">int</span> dr = tree[o].r ? partionMin(tree[o].r, k) : INF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过搜索顺序进行剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="comment">//如果最近可能的点都大于答案，那么不可能更新答案</span></span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans) query(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans) query(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans) query(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans) query(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化答案为无穷，从根节点开始，首先通过节点储存的点去更新答案。然后计算左右子树维护的矩形区域离当前查询的点的最近可能距离，然后首先搜距离近的，再搜远的，实际上就是一个剪枝。复杂度一般是$O(\log n)$，最差可能是$O(n \sqrt{n})$。</p>
<p>上面是曼哈顿距离，对于欧式几何距离用下面计算，也就是一个点到矩形的最近距离</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[o].minn[<span class="number">2</span>] &gt; tree[k].d[<span class="number">2</span>]) <span class="keyword">return</span> INF;</span><br><span class="line">    ll rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += sqr(tree[k].d[i] - tree[o].maxn[i]);</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += sqr(tree[o].minn[i] - tree[k].d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展成求到某个点最近的 k 个点也比较容易，查询的时候维护一个最大堆就可以了，之前的剪枝，就是对对顶进行比较了，如果大于堆顶一定不可能更新答案。</p>
<h1 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h1><h2 id="BZOJ-2648"><a href="#BZOJ-2648" class="headerlink" title="BZOJ 2648"></a>BZOJ 2648</h2><p>裸的 K-D 树题，求到某个点的最近曼哈顿距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIM = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[DIM], minn[DIM], maxn[DIM];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">            minn[i] = maxn[i] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[MAX * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;tree[p].l, tree[p].r&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!son[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">            tree[p].maxn[j] = max(tree[son[i]].maxn[j], tree[p].maxn[j]);</span><br><span class="line">            tree[p].minn[j] = min(tree[son[i]].minn[j], tree[p].minn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    tree[mid].maintain();</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += tree[k].d[i] - tree[o].maxn[i];</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += tree[o].minn[i] - tree[k].d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dm = <span class="built_in">abs</span>(tree[o].d[<span class="number">0</span>] - tree[k].d[<span class="number">0</span>]) + <span class="built_in">abs</span>(tree[o].d[<span class="number">1</span>] - tree[k].d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dm &lt; ans) ans = dm;</span><br><span class="line">    <span class="keyword">int</span> dl = tree[o].l ? partionMin(tree[o].l, k) : INF;</span><br><span class="line">    <span class="keyword">int</span> dr = tree[o].r ? partionMin(tree[o].r, k) : INF;</span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans) query(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans) query(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans) query(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans) query(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> k, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">0</span>) &#123;</span><br><span class="line">        o = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[k].d[now] &lt; tree[o].d[now]) insert(tree[o].l, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">else</span> insert(tree[o].r, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(o);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    n = read();</span><br><span class="line">    m = read();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) tree[i].d[j] = read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    pos = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        op = read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) tree[pos].d[j] = read();</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            tree[pos].maintain();</span><br><span class="line">            insert(root, pos, <span class="number">0</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = INF;</span><br><span class="line">            query(root, pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BZOJ-1941"><a href="#BZOJ-1941" class="headerlink" title="BZOJ 1941"></a>BZOJ 1941</h2><p>求每个点的最近点和最远的的距离差值最小的，用 K-D 树求每个点的最远点和最近点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIM = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[DIM], minn[DIM], maxn[DIM];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">            minn[i] = maxn[i] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[MAX * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;tree[p].l, tree[p].r&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!son[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">            tree[p].maxn[j] = max(tree[son[i]].maxn[j], tree[p].maxn[j]);</span><br><span class="line">            tree[p].minn[j] = min(tree[son[i]].minn[j], tree[p].minn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    tree[mid].maintain();</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ansMin, ansMax;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += tree[k].d[i] - tree[o].maxn[i];</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += tree[o].minn[i] - tree[k].d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partionMax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        rst += max(<span class="built_in">abs</span>(tree[k].d[i] - tree[o].minn[i]), <span class="built_in">abs</span>(tree[k].d[i] - tree[o].maxn[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dm = <span class="built_in">abs</span>(tree[o].d[<span class="number">0</span>] - tree[k].d[<span class="number">0</span>]) + <span class="built_in">abs</span>(tree[o].d[<span class="number">1</span>] - tree[k].d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == k) dm = INF;</span><br><span class="line">    <span class="keyword">if</span> (dm &lt; ansMin) ansMin = dm;</span><br><span class="line">    <span class="keyword">int</span> dl = tree[o].l ? partionMin(tree[o].l, k) : INF;</span><br><span class="line">    <span class="keyword">int</span> dr = tree[o].r ? partionMin(tree[o].r, k) : INF;</span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ansMin) queryMin(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ansMin) queryMin(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ansMin) queryMin(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ansMin) queryMin(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dm = <span class="built_in">abs</span>(tree[o].d[<span class="number">0</span>] - tree[k].d[<span class="number">0</span>]) + <span class="built_in">abs</span>(tree[o].d[<span class="number">1</span>] - tree[k].d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (dm &gt; ansMax) ansMax = dm;</span><br><span class="line">    <span class="keyword">int</span> dl = tree[o].l ? partionMax(tree[o].l, k) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dr = tree[o].r ? partionMax(tree[o].r, k) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dl &gt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &gt; ansMax) queryMax(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &gt; ansMax) queryMax(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &gt; ansMax) queryMax(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &gt; ansMax) queryMax(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;tree[i].d[<span class="number">0</span>], &amp;tree[i].d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ansMax = <span class="number">0</span>;</span><br><span class="line">            ansMin = INF;</span><br><span class="line">            queryMax(root, i);</span><br><span class="line">            queryMin(root, i);</span><br><span class="line">            ans = min(ans, ansMax - ansMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BZOJ-4066"><a href="#BZOJ-4066" class="headerlink" title="BZOJ 4066"></a>BZOJ 4066</h2><p>给出一个$n \times n$的棋盘，每次对其中的一个点修改中，询问一个矩形，求矩形内点的和。</p>
<p>这里插入的点的数量有点多，可能导致树的形态太差，所以插入点树每过 10000 就暴力重构一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIM = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> d[DIM], minn[DIM], maxn[DIM];</span><br><span class="line">    <span class="keyword">int</span> sum, v;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">            minn[i] = maxn[i] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum = v;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[MAX * <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;tree[p].l, tree[p].r&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!son[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">            tree[p].maxn[j] = max(tree[son[i]].maxn[j], tree[p].maxn[j]);</span><br><span class="line">            tree[p].minn[j] = min(tree[son[i]].minn[j], tree[p].minn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[p].sum = tree[son[<span class="number">0</span>]].sum + tree[p].v + tree[son[<span class="number">1</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    tree[mid].maintain();</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> xl, xr, yl, yr;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xr &lt; tree[o].minn[<span class="number">0</span>] || tree[o].maxn[<span class="number">0</span>] &lt; xl  ||</span><br><span class="line">        yr &lt; tree[o].minn[<span class="number">1</span>] || tree[o].maxn[<span class="number">1</span>] &lt; yl)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (xl &lt;= tree[o].minn[<span class="number">0</span>] &amp;&amp; tree[o].maxn[<span class="number">0</span>] &lt;= xr &amp;&amp;</span><br><span class="line">        yl &lt;= tree[o].minn[<span class="number">1</span>] &amp;&amp; tree[o].maxn[<span class="number">1</span>] &lt;= yr) &#123;</span><br><span class="line">        ans += tree[o].sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (xl &lt;= tree[o].d[<span class="number">0</span>] &amp;&amp; tree[o].d[<span class="number">0</span>] &lt;= xr &amp;&amp;</span><br><span class="line">        yl &lt;= tree[o].d[<span class="number">1</span>] &amp;&amp; tree[o].d[<span class="number">1</span>] &lt;= yr)</span><br><span class="line">        ans += tree[o].v;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (tree[o].l) query(tree[o].l);</span><br><span class="line">    <span class="keyword">if</span> (tree[o].r) query(tree[o].r);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> k, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="number">0</span>) &#123;</span><br><span class="line">        o = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree[k].d[now] &lt; tree[o].d[now]) insert(tree[o].l, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">else</span> insert(tree[o].r, k, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(o);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">bool</span> type = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (type) t ^= ans;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        op = read(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) tree[pos].d[j] = read();</span><br><span class="line">            tree[pos].v = read();</span><br><span class="line">            tree[pos].maintain();</span><br><span class="line">            insert(root, pos, <span class="number">0</span>);</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span> (pos % <span class="number">10000</span> == <span class="number">0</span>) root = build(<span class="number">1</span>, pos - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xl = read();</span><br><span class="line">            yl = read();</span><br><span class="line">            xr = read();</span><br><span class="line">            yr = read();</span><br><span class="line"> </span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            query(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-5992"><a href="#HDU-5992" class="headerlink" title="HDU 5992"></a>HDU 5992</h2><p>三维 K-D 树，求二维平面是距离某个点最近的点，并且第三维不超过某个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIM = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> d[DIM], minn[DIM], maxn[DIM];</span><br><span class="line">&#125; tree[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;tree[p].l, tree[p].r&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!son[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">            tree[p].maxn[j] = max(tree[son[i]].maxn[j], tree[p].maxn[j]);</span><br><span class="line">            tree[p].minn[j] = min(tree[son[i]].minn[j], tree[p].minn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) tree[mid].maxn[i] = tree[mid].minn[i] = tree[mid].d[i];</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(<span class="keyword">const</span> ll &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqr((ll) a.d[<span class="number">0</span>] - (ll) b.d[<span class="number">0</span>]) + sqr((ll) a.d[<span class="number">1</span>] - (ll) b.d[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[o].minn[<span class="number">2</span>] &gt; tree[k].d[<span class="number">2</span>]) <span class="keyword">return</span> INF;</span><br><span class="line">    ll rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += sqr(tree[k].d[i] - tree[o].maxn[i]);</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += sqr(tree[o].minn[i] - tree[k].d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans1;</span><br><span class="line"><span class="keyword">int</span> ans2, ansNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ll dm = dis(tree[o], tree[k]);</span><br><span class="line">    <span class="keyword">if</span> (tree[o].d[<span class="number">2</span>] &lt;= tree[k].d[<span class="number">2</span>] &amp;&amp; (dm &lt; ans1 || dm == ans1 &amp;&amp; tree[o].id &lt; ans2)) &#123;</span><br><span class="line">        ans1 = dm;</span><br><span class="line">        ans2 = tree[o].id;</span><br><span class="line">        ansNode = o;</span><br><span class="line">    &#125;</span><br><span class="line">    ll dl = tree[o].l ? partionMin(tree[o].l, k) : INF;</span><br><span class="line">    ll dr = tree[o].r ? partionMin(tree[o].r, k) : INF;</span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt;= ans1) query(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt;= ans1) query(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt;= ans1) query(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt;= ans1) query(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[i].d[j]);</span><br><span class="line">            tree[i].l = tree[i].r = <span class="number">0</span>;</span><br><span class="line">            tree[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[n + <span class="number">1</span>].d[j]);</span><br><span class="line">            ans1 = INF;</span><br><span class="line">            query(root, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, tree[ansNode].d[<span class="number">0</span>], tree[ansNode].d[<span class="number">1</span>], tree[ansNode].d[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-4347"><a href="#HDU-4347" class="headerlink" title="HDU 4347"></a>HDU 4347</h2><p>求 k 维的最近 m 个点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">50000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXDIM = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DIM;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> d[MAXDIM], minn[MAXDIM], maxn[MAXDIM];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">            minn[i] = maxn[i] = d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D;</span><br><span class="line">priority_queue&lt;pair&lt;ll, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.d[D] &lt; b.d[D];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;tree[p].l, tree[p].r&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!son[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">            tree[p].maxn[j] = max(tree[son[i]].maxn[j], tree[p].maxn[j]);</span><br><span class="line">            tree[p].minn[j] = min(tree[son[i]].minn[j], tree[p].minn[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    D = now;</span><br><span class="line">    nth_element(tree + l, tree + mid, tree + r + <span class="number">1</span>);</span><br><span class="line">    tree[mid].maintain();</span><br><span class="line">    <span class="keyword">if</span> (l &lt; mid) tree[mid].l = build(l, mid - <span class="number">1</span>, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; r) tree[mid].r = build(mid + <span class="number">1</span>, r, (now + <span class="number">1</span>) % DIM);</span><br><span class="line">    pushUp(mid);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(<span class="keyword">const</span> ll &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dis</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">    ll rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        rst += sqr((ll) a.d[i] - (ll) b.d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">partionMin</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ll rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &gt; tree[o].maxn[i]) rst += sqr(tree[k].d[i] - tree[o].maxn[i]);</span><br><span class="line">        <span class="keyword">if</span> (tree[k].d[i] &lt; tree[o].minn[i]) rst += sqr(tree[o].minn[i] - tree[k].d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ll dm = dis(tree[o], tree[k]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dm &lt; q.top().first) &#123;</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(make_pair(dm, o));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll dl = tree[o].l ? partionMin(tree[o].l, k) : INF;</span><br><span class="line">    ll dr = tree[o].r ? partionMin(tree[o].r, k) : INF;</span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt;= q.top().first) query(tree[o].l, k);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt;= q.top().first) query(tree[o].r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt;= q.top().first) query(tree[o].r, k);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt;= q.top().first) query(tree[o].l, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;DIM)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[i].d[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = build(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> t, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">        <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIM; i++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tree[n + <span class="number">1</span>].d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) q.push(make_pair(INF, <span class="number">-1</span>));</span><br><span class="line">            query(root, n + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                ans.push_back(q.top().second);</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"the closest %d points are:\n"</span>, m);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ans.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DIM; j++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, tree[ans[i]].d[j], j == DIM - <span class="number">1</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/11/20/cjsli5r3600fn3oc20jjrg4yn/" data-id="cjsli5r3600fn3oc20jjrg4yn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDUTOJ4079-Cirno-のさんすう教室-模拟" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/cjsli5qok005h3oc2aiy60se7/" class="article-date">
  <time datetime="2017-11-20T04:32:20.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/命题/">命题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/cjsli5qok005h3oc2aiy60se7/">SDUTOJ4079 - Cirno のさんすう教室(模拟)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2326/pid/4079" target="_blank" rel="noopener">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/2326/pid/4079</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给出若干个类似 “A + B = C” 的等式（ABC均为一位的正整数），其中每个等式有可能至多有一个位置为 “?”，运算符只有”+ - *”。</p>
<p>题目需要输出每个复原后的等式，有可能等式本来就不需要复原，保证问号也为一位的正整数。</p>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>不难发现每个问号都有一个唯一的解，然后就是一道小学的算术题了。</p>
<p>分情况判断：</p>
<ul>
<li>? + B = C，那么 ? = C - B</li>
<li>A * ? = C，那么 ? = C / A</li>
<li>以此类推….</li>
</ul>
<p>这里可能好多同学读字符的时候出了问题，这里说一下，scanf函数里面添加一个空白字符，在读取的时候可以忽略掉若干个空白字符，比如我scanf(“ %c”, &amp;ch)，就可以读取 “  1”，前者有一个空格，后者两个。</p>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">char</span> a, b, c, d, e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c %c %c %c %c"</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e);</span><br><span class="line">        a -= <span class="string">'0'</span>, c -= <span class="string">'0'</span>, e -= <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">'+'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                a = e - c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                c = e - a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = a + c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                a = e + c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                c = a - e;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = a - c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                a = e / c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'?'</span> - <span class="string">'0'</span>) &#123;</span><br><span class="line">                c = e / a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = a * c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c %c %c %c %c\n"</span>, a + <span class="string">'0'</span>, b, c + <span class="string">'0'</span>, d, e + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/11/20/cjsli5qok005h3oc2aiy60se7/" data-id="cjsli5qok005h3oc2aiy60se7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDUTOJ4071-绿博的帽子（前缀和）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/cjsli5qog005f3oc2eqgozvvf/" class="article-date">
  <time datetime="2017-11-20T04:21:22.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/命题/">命题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/cjsli5qog005f3oc2eqgozvvf/">SDUTOJ4071 - 绿博的帽子（前缀和）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/4071.html" target="_blank" rel="noopener">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/4071.html</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="给出-n-个数-a-1-a-2-a-3-dots-a-n-，进行-q-次询问，每次输出-sum-k-l-r-a-k-。"><a href="#给出-n-个数-a-1-a-2-a-3-dots-a-n-，进行-q-次询问，每次输出-sum-k-l-r-a-k-。" class="headerlink" title="给出 n 个数 $a_1, a_2, a_3 \dots a_n$，进行 q 次询问，每次输出 $\sum_{k = l}^r $$a_k$。"></a>给出 n 个数 $a_1, a_2, a_3 \dots a_n$，进行 q 次询问，每次输出 $\sum_{k = l}^r $$a_k$。</h1><p>给出 n 个数 $a_1, a_2, a_3 \dots a_n$，进行 q 次询问，每次输出 $\sum_{k = l}^r a_k$。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ced470192faae13e215fb3b57e28efad2f01fa7f</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>$1 \le n, m, l, r \le 100000, l \le r \le n$</p>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>题意很简单，但是如果直接用 for 循环去求 l 到 r 的和的话会超时，可以计算一下，最多有 100000 次询问，每次最差计算 100000 次，这样总共时间复杂度是 $10^{10}$，计算机一秒大概只能计算$10^{9}$次，所以肯定会超时。</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="这时候我们定义-S-i-sum-k-1-i-​-a-k​-，这样我们可以用一个-for-循环求出所有的-Si，这样对于每一个-l-r-的询问，我们用-S-r​-S-l-1-​-即是答案，这样总共的时间复杂度是-10-5​-。"><a href="#这时候我们定义-S-i-sum-k-1-i-​-a-k​-，这样我们可以用一个-for-循环求出所有的-Si，这样对于每一个-l-r-的询问，我们用-S-r​-S-l-1-​-即是答案，这样总共的时间复杂度是-10-5​-。" class="headerlink" title="这时候我们定义$S_i = \sum_{k=1}^i ​$ $a_k​$，这样我们可以用一个 for 循环求出所有的 Si，这样对于每一个 l, r 的询问，我们用 $S_r​$ $- S_{l - 1}​$即是答案，这样总共的时间复杂度是 $10^5​$。"></a>这时候我们定义$S_i = \sum_{k=1}^i ​$ $a_k​$，这样我们可以用一个 for 循环求出所有的 Si，这样对于每一个 l, r 的询问，我们用 $S_r​$ $- S_{l - 1}​$即是答案，这样总共的时间复杂度是 $10^5​$。</h1><p>这时候我们定义$S_i = \sum_{k=1}^i a_k$，这样我们可以用一个 for 循环求出所有的 Si，这样对于每一个 l, r 的询问，我们用 $S_r - S_{l - 1}$即是答案，这样总共的时间复杂度是 $10^5$。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ced470192faae13e215fb3b57e28efad2f01fa7f</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">112345</span>;</span><br><span class="line"><span class="keyword">int</span> S[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, S + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            S[i] += S[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[r] - S[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/11/20/cjsli5qog005f3oc2eqgozvvf/" data-id="cjsli5qog005f3oc2eqgozvvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ICPC青岛站总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/09/cjsli5qks003h3oc2z74zk3ls/" class="article-date">
  <time datetime="2017-11-09T06:38:32.000Z" itemprop="datePublished">2017-11-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/历程/">历程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/09/cjsli5qks003h3oc2z74zk3ls/">ICPC青岛站总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>老师要求每场比赛后要写一份总结…有点小学的时候强行每天写日记的感觉了。于是看看能不能写出点东西，就放在博客上了。</p>
<h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>总的来说体验一般吧，不论是坐车还是吃饭什么的，没有去哈尔滨或者杭州那么遥远的感觉，毕竟还没出省，（然后没有比赛的感觉？）。感觉两天时间一会就过去了，仿佛还没打比赛。然后到现在去青岛的经历都记不太清了…</p>
<h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>热身赛的时候还是打算先练练手了，最后排名好像是在银牌区，算是认真打了下。最后在想 C 题，突然奇想用线段树的维护信息方式去写字典树，然后好像就可以做了，不过到比赛结束还没有调出来有点可惜，回来的后补掉了一个类似的题。</p>
<p>正式赛惯例还是我来敲签到题，这两场的发挥还算正常，做完签到题能够在银牌区，不过出打印图形的题的时候算是失误了一下，出的比较慢，当时好像在 90 名左右。之后就去看那个字符串题了，按照后缀数组的暴力做法让队友敲了一个半小时才调过了样例，然后我试了下造的大数据，发现 1000 的数据两就差不多 TLE 了，然后就交，这时候我一直在想简单的算法，感觉 A 的人那么多，不可能这么多队都会后缀数组，然后写了一个最差情况下可能 T 的算法，交上去就 A 了。这时候排名 50 左右，银牌是肯定稳了，毕竟一个小时不可能滚上去 50 多个队。最后一小时读了一个题，然后一点思路都没有，最后一个小时算是很绝望了…</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这场比赛感觉题出的是真的不好，前三题是一点难度都没有，只要手速快点，胆子大点就莫名其妙的前 100 名了，这样随随便便就拿到的名次感觉都对不起平时的训练。不过有银牌还是非常开心的，自我评价我们队的水平也就是介于铜牌和银牌之间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/11/09/cjsli5qks003h3oc2z74zk3ls/" data-id="cjsli5qks003h3oc2z74zk3ls" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-51nod1378-夹克老爷的愤怒（树型DP-贪心）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/31/cjsli5qf9000a3oc2o0vj3vko/" class="article-date">
  <time datetime="2017-10-31T12:51:52.000Z" itemprop="datePublished">2017-10-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/DP/">DP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/cjsli5qf9000a3oc2o0vj3vko/">51nod1378 - 夹克老爷的愤怒（树型DP+贪心）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1378" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1378</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给出一张 N 个节点树形图，从中选若干个节点，使得途中任一节点距离最近的选中节点的距离不超过 K。</p>
<p>$1\le N\le 1e5, 0 \le K \le N$</p>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>树型DP，贪心的放，刚开始对于一颗子树，如果深度等于 K 那么肯定选中这颗子树的根节点。这时候这个选中的节点不仅对子孙节点有贡献，还对祖先或兄弟节点有贡献，这时候我们用一个数组 DP[i] 记录某个点可以做出多少贡献，或一个点需要多少的贡献。</p>
<p>比如选中了 u 节点，那么他具有 k 的贡献，他的父亲和孩子都有 k - 1的贡献。对于一个叶子节点视它为 0 点贡献，那么他的祖先就需要 -1 点贡献。</p>
<p>对于每个节点需要维护的是一颗子树的信息，要满足以它为根的子树里面的所有节点的需求。</p>
<p>通过以下方式进行转移：</p>
<p><code>minn = min(dp[child]), maxn = max(dp[child]);</code></p>
<p>如果当前节点为叶子节点，那么 <code>minn = maxn = 0</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if minn &lt;= -k				#这时 u 的子树中已经有一个节点需求为 -k，如果不选中当前节点肯定无解</span><br><span class="line">    dp[u] = k, ans++		</span><br><span class="line">else if maxn + minn &gt; 0		#这时 u 的子树中有一个节点的贡献可以满足其他节点的需求</span><br><span class="line">    dp[u] = maxn - 1</span><br><span class="line">else 						#如果不满足这两种情况，那么贪心的想，需求向祖先节点需求</span><br><span class="line">	dp[u] = minn - 1</span><br></pre></td></tr></table></figure>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn = INF;</span><br><span class="line">    <span class="keyword">int</span> maxn = -INF;</span><br><span class="line">    <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : edge[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">        minn = min(dp[v], minn);</span><br><span class="line">        maxn = max(dp[v], maxn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ok) maxn = minn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (minn &lt;= -k) dp[u] = k, ans++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maxn + minn &gt; <span class="number">0</span>) dp[u] = maxn - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> dp[u] = minn - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (dp[<span class="number">0</span>] &lt; <span class="number">0</span>) ans++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h1><p>在白书上看到了一个类似的题，然后扩展了一下，去群里问了下做法，感觉应该是很经典的题，然后人形题库 qls 就给出 51nod 上的原题，于是就补了一下。还是有一个坑点的，如果直接不考虑叶子节点的话，对于 k = 0 的情况需要特判。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/31/cjsli5qf9000a3oc2o0vj3vko/" data-id="cjsli5qf9000a3oc2o0vj3vko" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HDU4819-Mosaic（二维线段树-单点更新区间查询-模板）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/27/cjsli5qk100333oc27pz8g1vf/" class="article-date">
  <time datetime="2017-10-27T10:11:19.000Z" itemprop="datePublished">2017-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/数据结构/">数据结构</a>►<a class="article-category-link" href="/categories/ACM/数据结构/线段树/">线段树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/cjsli5qk100333oc27pz8g1vf/">HDU4819 - Mosaic（二维线段树-单点更新区间查询 + 模板）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://vjudge.net/problem/HDU-4819" target="_blank" rel="noopener">https://vjudge.net/problem/HDU-4819</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>给出一个 n <em> n 的矩阵，每个位置有一个整数值。进行 q 次操作，每次选矩阵的一个元素为中心，取以这个元素为中心的 L </em> L 的最大值和最小值，将这个元素的值赋值成最大值最小值的平均值。</p>
<p>$n \le 800, q \le 100000$</p>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>裸的二维线段树，单点修改，询问区间最值。</p>
<p>其实二维的线段树就是一个行线段树套列线段树，注意进行更新的时候，不能直接赋值修改，只修改行线段树叶子节点里面列线段树的叶子节点，然后向上合并。</p>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson o&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson o&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID int m = (l + r) &gt;&gt; 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//列线段树，用来维护列的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nodey</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Max, Min;</span><br><span class="line"></span><br><span class="line">    Nodey <span class="keyword">operator</span>+(<span class="keyword">const</span> struct Nodey &amp;t) &#123;</span><br><span class="line">        Nodey rst;</span><br><span class="line">        rst.Max = max(Max, t.Max);</span><br><span class="line">        rst.Min = min(Min, t.Min);</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> locy[MAX], locx[MAX];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//行线段树，用来维护行的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nodex</span> &#123;</span></span><br><span class="line">    Nodey sty[MAX &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        sty[o].Max = -INF;</span><br><span class="line">        sty[o].Min = INF;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            locy[l] = o;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MID;</span><br><span class="line">        build(lson, l, m);</span><br><span class="line">        build(rson, m + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Nodey <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt; l || r &lt; ql) <span class="keyword">return</span> (Nodey) &#123;-INF, INF&#125;;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sty[o];</span><br><span class="line">        MID;</span><br><span class="line">        <span class="keyword">return</span> query(lson, l, m, ql, qr) + query(rson, m + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; stx[MAX &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    stx[o].build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        locx[l] = o;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MID;</span><br><span class="line">    build(lson, l, m);</span><br><span class="line">    build(rson, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行单点更新，这里首先更新了叶子节点，然后向上合并父亲节点；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tx = locx[x];</span><br><span class="line">    <span class="keyword">int</span> ty = locx[y];</span><br><span class="line">    stx[tx].sty[ty].Min = stx[tx].sty[ty].Max = val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tx; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ty; j; j &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == tx &amp;&amp; j == ty) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == ty) &#123;</span><br><span class="line">                <span class="comment">//如果当前更新的列就是需要更新的叶子节点，那么由当前行的两个儿子节点来更新信息</span></span><br><span class="line">                stx[i].sty[j] = stx[i &lt;&lt; <span class="number">1</span>].sty[j] + stx[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sty[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则由当前列的如果儿子节点来更新</span></span><br><span class="line">                stx[i].sty[j] = stx[i].sty[j &lt;&lt; <span class="number">1</span>] +  stx[i].sty[j &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Nodey <span class="title">query</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qr &lt; l || r &lt; ql) <span class="keyword">return</span> (Nodey) &#123;-INF, INF&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> stx[o].query(<span class="number">1</span>, <span class="number">1</span>, n, y1, y2);</span><br><span class="line">    MID;</span><br><span class="line">    <span class="keyword">return</span> query(lson, l, m, ql, qr, y1, y2) + query(rson, m + <span class="number">1</span>, r, ql, qr, y1, y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        Case++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, Case);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">                Modify(i, j, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="keyword">int</span> x, y, L;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;x, &amp;y, &amp;L);</span><br><span class="line">            <span class="keyword">int</span> x1 = max(x - L / <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> x2 = min(x + L / <span class="number">2</span>, n);</span><br><span class="line">            <span class="keyword">int</span> y1 = max(y - L / <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> y2 = min(y + L / <span class="number">2</span>, n);</span><br><span class="line">            Nodey ans = query(<span class="number">1</span>, <span class="number">1</span>, n, x1, x2, y1, y2);</span><br><span class="line">            <span class="keyword">int</span> t = (ans.Max + ans.Min) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">            Modify(x, y, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h1><p>晚上模拟赛的题，感觉是一个二维线段树的裸题，但是不会，马上要去CCPC秦皇岛了，现学的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/27/cjsli5qk100333oc27pz8g1vf/" data-id="cjsli5qk100333oc27pz8g1vf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CCPC2017哈理工比赛总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/24/cjsli5qg3000p3oc2qapk8qng/" class="article-date">
  <time datetime="2017-10-24T12:54:18.000Z" itemprop="datePublished">2017-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/历程/">历程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/24/cjsli5qg3000p3oc2qapk8qng/">CCPC2017哈理工比赛总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是第一次参加的区域赛，老师又让写一份总结，于是凑一块写在这里好了。</p>
<h1 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h1><p>出发前准备的算是挺充分，当时还一直纠结着哈尔滨冷不冷，要带多厚的衣服过去，最后就随便带了几件，然后出发当天去超市买了一堆的东西，给手机缓存了几部动漫（路人女主，末日时，来自深渊，笨女孩…）。得出经验，只需要提前半小时能够到达火车站就好了。</p>
<p>在火车上一晚上看完了笨女孩，然后白天的路上看完了末日时。期间还有打打王者荣耀和斗地主，感觉好颓啊，最逗的是一个别的队的傻子，和我们斗地主积分输成负的时候，就要清理下手机的数据，重新变成1000分。路上还算是挺好的，不过一天三顿吃泡面有点绝望，发现买的零食都不怎么好吃。另外值得一提的就是路上遇到了一个别人家的熊孩子，特别烦。</p>
<p>到了哈尔滨刚下车也不算太冷，在火车站刚下车就见识到了东北的民风彪悍，门卫大爷开玩笑都是 “你过来，看我不揍你！”。然后晚上就搭车去旅馆了，还算是顺利。（不过我们的房间厕所没有门是几个意思啊？！）</p>
<p>晚上一起去吃了夜宵（算是？），没好吃的然后回宿舍订了外卖，发现外卖能直接送到酒店的房间里，体验贼好！</p>
<p>第二天睡到了九点半（晚上终末少女的旅行更新了，然后看了一集），发现步行只需要半小时就到学校了，报名领取发票也挺顺利的，然后在门外的牌子前面合影就去吃饭了。伙食感觉还行，至少有不少肉，能吃饱…米饭给的是有点少。</p>
<p>下午就是一个关于游戏开发的演讲，然后不知不觉的睡着了…</p>
<p>回去的时候就没什么意思了，因为时间问题结果没去成中央大街，只买了点超市里散卖的红肠。</p>
<h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>热身赛的时候前两题出的是比较顺的，我强行要攒人品，然后全场第一发的WA是我交的，然后测了测Java后，把所有题都WA了一发。然后就开始认真出题了，第一题就是个暴力，然后另一个是猜结论，我还强行打了一个表，最后没出B题有点可惜，赛后我还以为是要用线段树进行区间加，后来看大佬们的解释，发现改一下递推的方式就可以用前缀和优化掉了。</p>
<p>之后是正式赛，第一题，一个平时随手切的水题，比赛的时候居然卡了接近半小时，然后第二题也不算太难，卡了两个小时，最后吃午饭的时候讨论了下才A出来，可以说是相当绝望了，排名一直在100左右，觉得已经凉了，最后两个小时也没有出题。</p>
<p>不过最后的时候，居然能有铜牌，当时就很开心了，觉得打的这么差居然还有个牌子…</p>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>可能是第一次参加区域赛，状态不是很好，比赛也缺乏一些讨论，好多题型没见过，比如热身赛的DP用前缀和优化，之前没见过…</p>
<p>还有好多题都是没用到复杂的数据结构算法，都是需要一些思维和技巧的题，感觉之后还是要加大点刷题量，多学一点套路和技巧，多打打CF。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/24/cjsli5qg3000p3oc2qapk8qng/" data-id="cjsli5qg3000p3oc2qapk8qng" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2-SAT问题（模板）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/18/cjsli5qe400003oc26sndu104/" class="article-date">
  <time datetime="2017-10-18T01:32:46.000Z" itemprop="datePublished">2017-10-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/图论/">图论</a>►<a class="article-category-link" href="/categories/ACM/图论/2-SAT/">2-SAT</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/18/cjsli5qe400003oc26sndu104/">2-SAT问题（模板）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>2-SAT （<a href="https://en.wikipedia.org/wiki/2-satisfiability" target="_blank" rel="noopener">2-satisfiability</a>）是描述一个这样的问题，有 n 个 bool 变量 $x_i$，并且有 m 个需要满足的条件，比如： “$x_1$为真或$x_2$为假”，“ $x_1$ 为真或$x_2$为真”之类的条件，这里”或“是指两个条件中至少有一个为真。SAT的问题是确定这 n 个变量的值，使得满足所有的条件。</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>以下主要参考<a href="https://blog.sengxian.com/algorithms/2-sat" target="_blank" rel="noopener">Sengxian’s Blog</a>和刘汝佳的白书。</p>
<p>有一个比较容易理解的解法，首先将每一个变量当成两个图中的顶点，比如 $x_i$ 拆成 $2i$ 和 $2i + 1$ 两个节点，分表表示 $x_i$ 为假和真。比如标记了 $2i + 1$ 这个节点表示 $x_i$ 这个变量为真，如果标记了 $2i $ 则表示 $x_i$ 为假。</p>
<p>对于 “$x_i$ 为真或 $x_j$ 为假”这个条件，我们添加一条 $2i$ 到 $2j$ 的边，表示如果 $x_i$ 为假的话，那么要使得条件成立 $x_j$ 一定要为假。另外同理也要添加一条 $2j + 1$ 到 $2i + 1$的边。注意上面的都是有向边，这里的边可以当做逻辑上的推导出的意思。</p>
<p>这样根据上面建完图后，接下来逐一考虑没有标记的变量，设为 $x_i$。我们先假定它为假，然后标记节点 $2i$，并且沿着有向边标记所有能标记的节点。如果标记过程中发现某个变量所对应的两个节点都被标记了，则 “ $x_i$ 为假” 这个假定不成立，需要改成 “ $x_i$ 为真”，然后退回到标记 “ $x_i$ 为假” 之前的状态，重新操作。注意，如果当前考虑的变量不管是真是假都会引起矛盾，可以证明整个 2-SAT 问题无解（即使调整以前赋值的其他变量都没用），所以这个算法是没有回溯过程的，这样最差的复杂度是 $O(N \cdot M)$。</p>
<p>其实对于 2-SAT 问题还 $O(M)$ 的算法，不过对于 2-SAT 问题一般是考的建图方式，不卡时间，这里给出几个链接：</p>
<ul>
<li><a href="http://blog.csdn.net/hqd_acm/article/details/5881655" target="_blank" rel="noopener">http://blog.csdn.net/hqd_acm/article/details/5881655</a></li>
<li><a href="http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html" target="_blank" rel="noopener">http://www.cppblog.com/MatoNo1/archive/2015/12/29/150766.html</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TwoSat</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_NODE = <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAX_NODE];</span><br><span class="line">    <span class="keyword">int</span> n, stk[MAX_NODE], sz;</span><br><span class="line">    <span class="keyword">bool</span> mark[MAX_NODE];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; ++i) G[i].clear();</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addClause</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> xVal, <span class="keyword">int</span> y, <span class="keyword">int</span> yVal)</span> </span>&#123;</span><br><span class="line">        x = x * <span class="number">2</span> + xVal, y = y * <span class="number">2</span> + yVal;</span><br><span class="line">        G[x ^ <span class="number">1</span>].push_back(y);</span><br><span class="line">        G[y ^ <span class="number">1</span>].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[x ^ <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mark[x]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stk[sz++] = x;</span><br><span class="line">        mark[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[x].size(); ++i)</span><br><span class="line">            <span class="keyword">if</span> (!dfs(G[x][i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (!mark[i] &amp;&amp; !mark[i ^ <span class="number">1</span>]) &#123;</span><br><span class="line">                sz = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!dfs(i)) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (sz &gt; <span class="number">0</span>) mark[stk[--sz]] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!dfs(i ^ <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>上面描述的条件都只是 “或”，即是两个之中有一个成立，这里可以通过多个“或”条件的组合产生其他的逻辑条件。</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>转化</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>$a=b$</td>
<td>$a \vee \lnot b \bigwedge \lnot a \vee b  $</td>
<td>add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>
</tr>
<tr>
<td>$a \neq b$</td>
<td>$a \vee b \bigwedge \lnot a \vee \lnot b$</td>
<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 1);</td>
</tr>
<tr>
<td>$a = b = true$</td>
<td>$a \vee \lnot b \bigwedge \lnot a \vee b  \bigwedge a \vee b$</td>
<td>add_clause(a, 1, b, 1); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>
</tr>
<tr>
<td>$a = b = false$</td>
<td>$a \vee \lnot b \bigwedge \lnot a \vee b  \bigwedge \lnot a \vee  \lnot b$</td>
<td>add_clause(a, 0, b, 0); add_clause(a, 1, b, 0); add_clause(a, 0, b, 1);</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/18/cjsli5qe400003oc26sndu104/" data-id="cjsli5qe400003oc26sndu104" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-URAL1183-Brackets-Sequence（区间DP）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/16/cjsli5qp4005r3oc2cptdfqzo/" class="article-date">
  <time datetime="2017-10-16T01:01:19.000Z" itemprop="datePublished">2017-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/DP/">DP</a>►<a class="article-category-link" href="/categories/ACM/DP/区间DP/">区间DP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/16/cjsli5qp4005r3oc2cptdfqzo/">URAL1183 - Brackets Sequence（区间DP）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1183" target="_blank" rel="noopener">http://acm.timus.ru/problem.aspx?space=1&amp;num=1183</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p><a href="http://blog.csdn.net/jiange_zh/article/details/49994207" target="_blank" rel="noopener">参考博客</a></p>
<blockquote>
<p>定义正规的括号序列如下: </p>
<ol>
<li>空序列是一个正规的括号序列 </li>
<li>如果S是一个正规的括号序列, 那么(S) 和[S] 也都是正规的括号序列。 </li>
<li>如果A和B是正规的括号序列, 那么AB也是一个正规的括号序列。 </li>
</ol>
<p>现给定一个括号序列A（只包含小括号和中括号，可能为空序列），求一个正规括号序列B，使得A包含于B，而且B的长度是满足条件的序列中最小的。</p>
</blockquote>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>设 $dp[i][j]$ 为使得 [i, j] 这段区间括号匹配所需要的最小花费，那么根据题意，$dp[i][j]$可由两种方式转移而来：</p>
<ul>
<li>如果 i 与 j 可以匹配的话$dp[i][j] = dp[i + 1][j - 1]$</li>
<li>不关 i 与 j 是否匹配 $dp[i][k] = dp[i][k] + dp[k + 1][j]$</li>
</ul>
<p>最后递归的打印答案，转移的时候标记一下，当前是否分为两个子序列。</p>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1123</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">112</span>][<span class="number">112</span>];</span><br><span class="line"><span class="keyword">int</span> mark[<span class="number">112</span>][<span class="number">112</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">'('</span> || s[l] == <span class="string">')'</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"()"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"[]"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mark[l][r] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">            print(l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span>;</span><br><span class="line">            print(l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print(l, mark[l][r]);</span><br><span class="line">        print(mark[l][r] + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gets(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> &amp;&amp; s[j] == <span class="string">')'</span> || s[i] == <span class="string">'['</span> &amp;&amp; s[j] == <span class="string">']'</span>) &#123;</span><br><span class="line">                dp[i][j] = min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mark[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][k] + dp[k + <span class="number">1</span>][j] &lt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][k] + dp[k + <span class="number">1</span>][j];</span><br><span class="line">                    mark[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h1><p>这题卡了好久ORZ，之前了解过一点区间DP，结果还是不会做。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/16/cjsli5qp4005r3oc2cptdfqzo/" data-id="cjsli5qp4005r3oc2cptdfqzo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HihoCoder1424-Asa-s-Chess-Problem（有上下流量限制的费用流）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/16/cjsli5qkw003k3oc2y045yna6/" class="article-date">
  <time datetime="2017-10-15T23:53:42.000Z" itemprop="datePublished">2017-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>►<a class="article-category-link" href="/categories/ACM/图论/">图论</a>►<a class="article-category-link" href="/categories/ACM/图论/网络流/">网络流</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/16/cjsli5qkw003k3oc2y045yna6/">HihoCoder1424 - Asa&#39;s Chess Problem（有上下流量限制的费用流）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h1><p><a href="https://vjudge.net/problem/HihoCoder-1424" target="_blank" rel="noopener">https://vjudge.net/problem/HihoCoder-1424</a></p>
<h1 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h1><p>参考 <a href="http://www.cnblogs.com/flipped/p/7635420.html" target="_blank" rel="noopener">http://www.cnblogs.com/flipped/p/7635420.html</a></p>
<blockquote>
<p>有个 N×N 的棋盘，告诉你每个格子黑色(1)或白色(0)，以及每对能相互交换的同行或同列格子，每个格子只在一对中，即共有N×N/2对。求最少交换次数使得每行每列的黑格子总数满足给出的上下范围：若最终第i行,第j列分别有R[i],C[j]个黑格子，那么需要让Rl[i]≤R[i]≤Rh[i],Cl[j]≤C[i]≤Ch[j]。</p>
</blockquote>
<h1 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h1><p>这里先介绍一种有流量下限限制的建图方式，参考<a href="http://www.cnblogs.com/kane0526/archive/2013/04/05/3001108.html" target="_blank" rel="noopener">这个博客</a>。</p>
<p>记节点 i 所有流入的流量下限和为 in[i]，所有的流出流入和下限为 out[i]，建一个超级源点 SS，超级汇点 ST。</p>
<p>如果一个节点 in[i] &gt; out[i]，那么建一条 SS 到 i 的边，流量为 in[i] - out[i]。</p>
<p>如果 in[i] &lt; out[i]，那么建一条 i 到 ST 的边，流量为 out[i] - in[i]。</p>
<p>对于无源汇的图来说，上面从 SS 到 ST跑一个最大流，如果上面的从 SS 出发的附加边满流，当前就是一个可行流，否则无解。</p>
<p>对于有源汇的图来说，需要从 T 到 S 连一条流量为无穷的边，然后再从 SS 到 ST 跑最大流。 </p>
<p>对于这个题，设每一行每一列原有的黑色棋子数量为 R[i] 和 C[i]。</p>
<ul>
<li>首先从 S 到每一行每一列建一条上下限均为 R[i] 或 C[i] 的边</li>
<li>每一行每一列对 T 建边，容量上下限为 Rl[i]， Rh[i] 或 Cl[i]，Ch[i]</li>
<li>然后对于可以交换的棋子，如果他们颜色相同，那么不需要建边，否则如果列相同，黑色所在的行向白色棋子所在的行建流量下限为 0 上限为 1 费用为 1 的边，列相同类似</li>
<li>从 t 到 s 建一条流量下限为 0，上限为无穷的边。</li>
</ul>
<p>上述所有边默认费用为 0 。</p>
<h1 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">112</span>][<span class="number">112</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c, w, nxt;</span><br><span class="line">&#125; edge[MAX * MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAX], etot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">112</span>], out[<span class="number">112</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> low, <span class="keyword">int</span> up, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[etot].u = u;</span><br><span class="line">    edge[etot].v = v;</span><br><span class="line">    edge[etot].c = up - low;</span><br><span class="line">    edge[etot].w = w;</span><br><span class="line">    edge[etot].nxt = head[u];</span><br><span class="line">    head[u] = etot++;</span><br><span class="line"></span><br><span class="line">    out[u] += low;</span><br><span class="line"></span><br><span class="line">    edge[etot].u = v;</span><br><span class="line">    edge[etot].v = u;</span><br><span class="line">    edge[etot].c = <span class="number">0</span>;</span><br><span class="line">    edge[etot].w = -w;</span><br><span class="line">    edge[etot].nxt = head[v];</span><br><span class="line">    head[v] = etot++;</span><br><span class="line"></span><br><span class="line">    in[v] += low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX], vis[MAX], pre[MAX], flow[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    flow[s] = <span class="number">1e9</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = edge[i].nxt) &#123;</span><br><span class="line">            Edge &amp;e = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (edge[i].c &gt; <span class="number">0</span> &amp;&amp; dist[e.v] &gt; dist[e.u] + e.w) &#123;</span><br><span class="line">                dist[e.v] = dist[e.u] + e.w;</span><br><span class="line">                pre[e.v] = i;</span><br><span class="line">                flow[e.v] = min(flow[e.u], e.c);</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.v]) &#123;</span><br><span class="line">                    vis[e.v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; min_cost_flow(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">    <span class="keyword">int</span> rst = <span class="number">0</span>, total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        spfa(s);</span><br><span class="line">        <span class="keyword">if</span> (dist[e] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> d = flow[e], u = e;</span><br><span class="line">        total += d;</span><br><span class="line">        rst += dist[e] * d;</span><br><span class="line">        <span class="keyword">while</span> (u != s) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = pre[u];</span><br><span class="line">            edge[last].c -= d;</span><br><span class="line">            edge[last ^ <span class="number">1</span>].c += d;</span><br><span class="line">            u = edge[last].u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make_pair(total, rst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Rl[<span class="number">112</span>], Rh[<span class="number">112</span>], Cl[<span class="number">112</span>], Ch[<span class="number">112</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row[<span class="number">112</span>], col[<span class="number">112</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">        etot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">        <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//源点，汇点，超级源点，超级汇点</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ss = e + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> se = ss + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data[i][j]);</span><br><span class="line">                row[i] += data[i][j];</span><br><span class="line">                col[j] += data[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Rl[i], &amp;Rh[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Cl[i], &amp;Ch[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            add_edge(s, i, row[i], row[i], <span class="number">0</span>);</span><br><span class="line">            add_edge(s, i + n, col[i], col[i], <span class="number">0</span>);</span><br><span class="line">            add_edge(i, e, Rl[i], Rh[i], <span class="number">0</span>);</span><br><span class="line">            add_edge(i + n, e, Cl[i], Ch[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            <span class="keyword">if</span> (data[x1][y1] == data[x2][y2]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[x1][y1] == <span class="number">0</span>) swap(x1, x2), swap(y1, y2);</span><br><span class="line">            <span class="keyword">if</span> (x1 == x2) &#123;</span><br><span class="line">                add_edge(n + y1, n + y2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) &#123;</span><br><span class="line">                add_edge(x1, x2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        add_edge(e, s, <span class="number">0</span>, <span class="number">1e9</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对超级源点，超级汇点建边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = in[i] - out[i];</span><br><span class="line">            <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                t = -t;</span><br><span class="line">                add_edge(i, se, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += t;</span><br><span class="line">                add_edge(ss, i, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ans = min_cost_flow(ss, se);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans.first != sum) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h1><p>这个题感觉也不是很难，感觉应该做出来的，关键是比赛的时候漏看了一个条件，只有列或行相同时才可以交换，如果没有这个条件建图就复杂了，当时也想麻烦了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://li-fish.github.io/2017/10/16/cjsli5qkw003k3oc2y045yna6/" data-id="cjsli5qkw003k3oc2y045yna6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/">ACM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/">DP</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/区间DP/">区间DP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/数位DP/">数位DP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/斜率优化/">斜率优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/树型DP/">树型DP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/DP/状压DP/">状压DP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/二分/">二分</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/二进制/">二进制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/命题/">命题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/">图论</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/2-SAT/">2-SAT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/匹配/">匹配</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/差分约束/">差分约束</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/最短路/">最短路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/网络流/">网络流</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/图论/连通性/">连通性</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/字符串/">字符串</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/字符串/AC自动机/">AC自动机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/字符串/后缀数组/">后缀数组</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/字符串/回文树/">回文树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/字符串/字符串Hash/">字符串Hash</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/搜索/">搜索</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/搜索/BFS/">BFS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数学/">数学</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数学/数论/">数论</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数学/矩阵快速幂/">矩阵快速幂</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数学/线性基/">线性基</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数学/高斯消元/">高斯消元</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/K-D树/">K-D树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/LCT/">LCT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/ST表/">ST表</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/Splay/">Splay</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/主席树/">主席树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/并查集/">并查集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/栈/">栈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/树/">树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/树链剖分/">树链剖分</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/线段树/">线段树</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/数据结构/虚树/">虚树</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/模拟/">模拟</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/知识小结/">知识小结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/计算几何/">计算几何</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/贪心/">贪心</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS课程/">CS课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/历程/">历程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/命题/">命题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/想法/">想法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂物/">杂物</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/游戏/">游戏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/爬虫-数据处理/">爬虫&数据处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/网页设计/">网页设计</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/网页设计/Web服务器/">Web服务器</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/音乐/">音乐</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/音乐/乐理/">乐理</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/26/cjsli5qs500773oc2mdgw2p6a/">吉比特实习面试</a>
          </li>
        
          <li>
            <a href="/2019/01/15/cjsli5quk008d3oc2kcqw2aez/">概率论笔记</a>
          </li>
        
          <li>
            <a href="/2018/11/16/cjsli5qs800793oc2c5bz1tsh/">二维ST表</a>
          </li>
        
          <li>
            <a href="/2018/10/16/cjsli5qo000553oc2advqly91/">SDUTACM十周年题解（Fish出题部分）</a>
          </li>
        
          <li>
            <a href="/2018/09/25/cjsli5qla003p3oc221qr9bgx/">LCT(模板-待填坑)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Fish<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



				<!-- MathJax -->
		<script type="text/x-mathjax-config">
			MathJax.Hub.Config({
				showProcessingMessages: false,
				tex2jax: {
					inlineMath: [["$", "$"], ["\\\\(", "\\\\)"]],
					processEscapes:true
				},
				menuSettings: {
					zoom: "Hover"
    			}
			});
		</script>
		<script src="//cdn.bootcss.com/mathjax/2.6.0/MathJax.js?config=TeX-AMS_HTML"></script>
				
  </div>
</body>
</html>